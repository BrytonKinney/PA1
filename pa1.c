/*
 * Programming Assignment 1 Sample Code.
 *
 * In programming assignment 1, you will implement a version of the
 * "ls" command.  The output of your ls command should look like the
 * output generated by the Linux "ls -l" command.  Your version should
 * implement the "-R" parameter; directories should be searched
 * recursively, if the "-R" parameter is present on the command line.
 *
 * Based on source code found in man 2 scandir.
 *
 * This program prints the names of the files in the current directory.
 * It uses scandir() to retrieve the file list.  betasort() is defined
 * as -alphasort(), so that file names are sorted in ascending order.
 *
 *
 * Copyright 2017, Timothy J. Salo.
 */

#include <dirent.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#define DIRECTORY "/"


/* Forward references. */

int betasort(const struct dirent **a, const struct dirent **b);
int fileCount = 0, directoryCount = 0, linkCount = 0, isRecursive = 0;
char* directory = DIRECTORY;        // directory path provided by user
int recCount = 0;
struct dirent ** mDir;
void RecursiveList(char * full_path, struct dirent ** namelist, struct stat file_status, int n, int callAgain)
{
	struct dirent ** nextDir;
	char * nextRp = realpath(full_path, NULL);
	if(callAgain == 0)
	{
		strcpy(full_path, nextRp);
		strcat(full_path, "/");
		if (full_path[strlen(full_path)-1] != '/')
			strcat(full_path, "/");
		strcat(full_path, namelist[n]->d_name);
	}
	int x = scandir(nextRp, &nextDir, NULL, betasort);
	/* Get file status. */
	while(x--)
	{
		 stat(full_path, &file_status);
		 switch (nextDir[x]->d_type) {
			case DT_REG:
			    for(int m = 0; m < recCount; m++)
				printf("> ");
			    fileCount++;
			    printf("File ");
            		    printf("\%8ld  %s  %s \n", file_status.st_size, nextDir[x]->d_name, full_path);
			    break;
			case DT_DIR:
			    directoryCount++;
	    	    	    callAgain = 1;
			    stat(full_path, &file_status);
			    for(int m = 0; m < recCount; m++)
				printf("> ");
			    printf("Dir  ");
		   	    printf("%8ld  %s  %s\n", file_status.st_size, nextDir[x]->d_name, full_path);
			    if(strcmp(nextDir[x]->d_name, ".") != 0 && strcmp(nextDir[x]->d_name, "..") != 0)
			    {
				recCount++;
				int z = strlen(full_path);
				int p = z;
				int charsTilSlash = 0;
				while(z--)
				{
					charsTilSlash++;
					if(full_path[z] == '/')
						break;
				}
				int q = p - charsTilSlash;
				char newPath[1024];
				for(int a = 0; a < q; a++)
				{
					char * nextChar = full_path[a];
					newPath[a] = nextChar;
					newPath[a + 1] = '\0';
				}
			    	if (newPath[strlen(newPath)-1] != '/')
					strcat(newPath, "/");
			    	strcat(newPath, nextDir[x]->d_name);
		    		if(strcmp(nextDir[x]->d_name, ".") != 0 && strcmp(nextDir[x]->d_name, "..") != 0)
				{
				    	if (newPath[strlen(newPath)-1] != '/')
						strcat(newPath, "/");
					int u = scandir(newPath, nextDir[x], NULL, betasort);
    					RecursiveList(newPath, &nextDir[x], file_status, u, recCount);
					recCount--;
					free(nextDir[x]);
				}
			    }
			    break;
			case DT_LNK:
			    for(int m = 0; m < recCount; m++)
				printf("> ");
			    linkCount++;
			    printf("\tLink ");
            		    printf("\%8ld  %s  %s\n", file_status.st_size, nextDir[x]->d_name, full_path);
			    break;
			default:
			    for(int m = 0; m < recCount; m++)
				printf("> ");
			    printf("\tOther");
				printf("\%8ld  %s  %s\n", file_status.st_size, nextDir[x]->d_name, full_path);
			    break;
		};
	}
}
/* main */

int main(int argc, char** argv) {

    /* In this version of the code, the directory to list is compiled in.
     * The directory to list should really be specified as a command line
     * parameter.
     */

    for(int i = 0; i < argc; i++)
    {
	printf("Arg %d: %s \n", i, argv[i]);
	if(i > 0)
	{
		if(strcmp(argv[i], "-R") == 0)
		{
	    		isRecursive = 1;
		        printf("-R supplied. Recursively searching directories...\n");
		}
		else
		{
	    		printf("Searching directory '%s'\n", argv[i]);
	    		directory = argv[i];
		}
	}
    }

    char* real_path;                    // path with ".", "..", etc. resolved
    char full_path[1024];               // full path of file to stat
    int n;                              // all-purpose int

    /* struct dirent
     *
     * See "man scandir"
     *
     * Used by scandir()
     *
     * From: /usr/include/x86_64-linux-gnu/bits/dirent.h
     *
     * struct dirent {
     *     __ino_t d_ino;                // inode number
     *     __off_t d_off;                // offset to next dirent
     *     unsigned short int d_reclen;  // length of this record
     *     unsigned char d_type;         // file type
     *     char d_name[256];             // file/directory name
     * };
     */

    struct dirent **namelist;            // directory entry struct

    /* struct stat
     *
     * see "man 2 stat"
     *
     * Used by stat()
     *
     * From: sys/stat.h
     *
     * struct stat {
     *     dev_t     st_dev;         // ID of device containing file
     *     ino_t     st_ino;         // inode number
     *     mode_t    st_mode;        // protection
     *     nlink_t   st_nlink;       // number of hard links
     *     uid_t     st_uid;         // user ID of owner
     *     gid_t     st_gid;         // group ID of owner
     *     dev_t     st_rdev;        // device ID (if special file)
     *     off_t     st_size;        // total size, in bytes
     *     blksize_t st_blksize;     // blocksize for filesystem I/O
     *     blkcnt_t  st_blocks;      // number of 512B blocks allocated
     *     struct timespec st_atim;  // time of last access
     *     struct timespec st_mtim;  // time of last modification
     *     struct timespec st_ctim;  // time of last status change
     * };
     */

    struct stat file_status;             // file status struct
    struct stat fstatus;
    /* Get real path - resolve path specified by user to a real path.
     *
     * see "man 3 realpath"
     */

    real_path = realpath(directory, NULL);

    // Process errors

    if (real_path == NULL) {
        switch (errno) {
            case EACCES: printf("EACCES: Access denied\n"); break;
            case EFAULT: printf("EFAULT\n"); break;
            case EINVAL: printf("EINVAL: Path is null\n"); break;
            case EIO: printf("EIO: I/O error occurred\n"); break;
            case ELOOP: printf("ELOOP: Too many symbolic links\n"); break;
            case ENAMETOOLONG: printf("ENAMETOOLONG: Path name too long\n"); break;
            case ENOENT: printf("ENOENT: File does not exist\n"); break;
            case ENOMEM: printf("ENOMEM: Out of memory\n"); break;
            case ENOTDIR: printf("ENOTDIR: Component of path not a directory\n"); break;
            default: printf("Unknown error\n"); break;
        }
        return -1;                      // exit
    }

    /* Print welcome messages. */

    printf("****** CS 442 Sample Code for Progamming Assignment 1 ******\n\n");

    /* Check if path points to a directory. */

    n = stat(real_path, &file_status);

    if (n < 0) {
        printf("Error getting directory status.\n");
        return -1;
    }

    // Check if path points to directory.

    if ((file_status.st_mode & S_IFMT) != S_IFDIR) {
        printf("Error: path is not a directory.\n");
        return -1;
    }
    
    /* Print rest of headers. */

    printf("Directory listing of: %s\n", real_path);
    printf("Type  Size      Name\tFull Path\n");

    /* Get the directory entries. */

    n = scandir(directory , &namelist, NULL, betasort);
    if (n < 0)
        perror("scandir");
    else {

        /* Print file type. */

        while (n--) {
            switch (namelist[n]->d_type) {
                case DT_REG:
		    fileCount++;
                    printf("File ");
                    break;
                case DT_DIR:
                    directoryCount++;
                    printf("Dir  ");
                    break;
                case DT_LNK:
		    linkCount++;
                    printf("Link ");
                    break;
                default:
                    printf("Other");
                    break;
            };

            /* Get file size from file status struct. */

            /* Build full absoute path name of file or directory`. */

            strcpy(full_path, real_path);
            strcat(full_path, "/");
            if (full_path[strlen(full_path)-1] != '/')
                strcat(full_path, "/");
            strcat(full_path, namelist[n]->d_name);

            /* Get file status. */

            stat(full_path, &file_status);
            /* Print file size, file name. */
	    printf("%8ld  %s\t  %s\n", file_status.st_size, namelist[n]->d_name, full_path);
	    if(namelist[n]->d_type == DT_DIR && isRecursive == 1 && strcmp(namelist[n]->d_name, ".") != 0 && strcmp(namelist[n]->d_name, "..") != 0)
	    {
            	    if (full_path[strlen(full_path)-1] != '/')
                	strcat(full_path, "/");
		    recCount = 0;
		    printf("%s", full_path);
		    RecursiveList(full_path, &namelist[n], file_status, n, 0);
            }

            free(namelist[n]);
        }
        free(namelist);
    }
    printf("Total files: %d\nTotal directories: %d\nTotal links: %d\n", fileCount, directoryCount, linkCount);
}


/* betasort - sort file names in ascending order. */

int betasort(const struct dirent **a, const struct dirent **b) {
    return -alphasort(a, b);
}
